name: Deploy to EC2
on:
  push:
    branches: [ master ]
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install Dependencies
        run: npm ci

      - name: Run tests
        run: npm test || true

      - name: Update server.ts for HTTPS support
        run: |
          cat > server.ts << 'EOF'
          // Arquivo principal do servidor
          import express from "express";
          import cors from "cors";
          import router from "./src/routes/route";
          import https from "https";
          import http from "http";
          import fs from "fs";
          import path from "path";

          // Import do banco jÃ¡ inicializa graÃ§as ao initDB() no mÃ³dulo
          import './src/database/database';

          const app = express();
          const port = process.env.PORT || 3000;
          const httpsPort = process.env.HTTPS_PORT || 3443;

          // Middlewares
          app.use(express.json());
          app.use(cors());

          // Rotas
          app.use("/api", router);

          // Rota simples para teste
          app.get("/", (req, res) => {
            res.json({ message: "API de Plantas - Servidor funcionando!" });
          });

          // Inicia o servidor HTTP
          http.createServer(app).listen(port, () => {
            console.log(`Servidor HTTP rodando na porta ${port}`);
          });

          // Verifica se os arquivos SSL existem
          const sslPath = path.join(__dirname, 'ssl');
          const privateKeyPath = path.join(sslPath, 'privkey.pem');
          const certificatePath = path.join(sslPath, 'cert.pem');
          const chainPath = path.join(sslPath, 'chain.pem');

          // FunÃ§Ã£o para verificar se o diretÃ³rio SSL existe e os arquivos necessÃ¡rios
          const sslFilesExist = () => {
            if (!fs.existsSync(sslPath)) return false;
            return fs.existsSync(privateKeyPath) && 
                   fs.existsSync(certificatePath) && 
                   fs.existsSync(chainPath);
          };

          // Inicia o servidor HTTPS se os arquivos SSL existirem
          if (sslFilesExist()) {
            const credentials = {
              key: fs.readFileSync(privateKeyPath, 'utf8'),
              cert: fs.readFileSync(certificatePath, 'utf8'),
              ca: fs.readFileSync(chainPath, 'utf8')
            };

            https.createServer(credentials, app).listen(httpsPort, () => {
              console.log(`Servidor HTTPS rodando na porta ${httpsPort}`);
            });
          } else {
            console.log('Arquivos SSL nÃ£o encontrados. Servidor HTTPS nÃ£o iniciado.');
            console.log('Para habilitar HTTPS, coloque os arquivos SSL no diretÃ³rio:');
            console.log(sslPath);
          }
          EOF

      - name: Create certificate setup script
        run: |
          cat > setup-ssl.sh << 'EOF'
          #!/bin/bash
          set -e

          echo "==== SSL Certificate Setup Script ===="

          # Stop server to free port 80 for certbot
          echo "Stopping server if running..."
          pm2 stop plants-api || true

          # Install certbot if not already installed
          if ! command -v certbot &> /dev/null; then
            echo "Installing certbot..."
            if [ -f /etc/redhat-release ]; then
              # CentOS/RHEL/Amazon Linux
              sudo amazon-linux-extras install epel -y
              sudo yum install certbot -y
            else
              # Ubuntu/Debian
              sudo apt-get update
              sudo apt-get install certbot -y
            fi
          fi

          # Get the server domain name
          DOMAIN=$(curl -s http://169.254.169.254/latest/meta-data/public-hostname)
          echo "Server domain: $DOMAIN"

          # Create SSL directory if it doesn't exist
          mkdir -p ~/app/ssl

          # Check if we have valid certificates
          if [ -d "/etc/letsencrypt/live/$DOMAIN" ]; then
            echo "Found existing certificates for $DOMAIN"
          else
            echo "Requesting new certificates from Let's Encrypt..."
            sudo certbot certonly --standalone \
              --preferred-challenges http \
              -d $DOMAIN \
              --agree-tos \
              --email admin@example.com \
              --non-interactive
            echo "Certificates obtained successfully!"
          fi

          # Copy certificates to app directory
          echo "Copying certificates to app directory..."
          sudo cp /etc/letsencrypt/live/$DOMAIN/privkey.pem ~/app/ssl/
          sudo cp /etc/letsencrypt/live/$DOMAIN/cert.pem ~/app/ssl/
          sudo cp /etc/letsencrypt/live/$DOMAIN/chain.pem ~/app/ssl/

          # Fix permissions
          sudo chown -R $(whoami):$(whoami) ~/app/ssl
          chmod 600 ~/app/ssl/*.pem

          # Verify files
          echo "Verifying SSL files..."
          ls -la ~/app/ssl/

          # Create certificate renewal script
          echo "Creating certificate renewal script..."
          cat > ~/renew-cert.sh << 'RENEWAL'
          #!/bin/bash
          DOMAIN=$(curl -s http://169.254.169.254/latest/meta-data/public-hostname)

          # Stop the application
          pm2 stop plants-api

          # Renew the certificate
          certbot renew --quiet

          # Copy the renewed certificates
          sudo cp /etc/letsencrypt/live/$DOMAIN/privkey.pem ~/app/ssl/
          sudo cp /etc/letsencrypt/live/$DOMAIN/cert.pem ~/app/ssl/
          sudo cp /etc/letsencrypt/live/$DOMAIN/chain.pem ~/app/ssl/

          # Fix permissions
          chmod 600 ~/app/ssl/*.pem

          # Restart the application
          pm2 restart plants-api

          # Log the renewal
          echo "Certificate renewed on $(date)" >> ~/cert-renewal.log
          RENEWAL

          chmod +x ~/renew-cert.sh

          # Set up cron job for automatic renewal if not already set
          if ! crontab -l 2>/dev/null | grep -q "renew-cert.sh"; then
            echo "Setting up automatic certificate renewal..."
            (crontab -l 2>/dev/null; echo "0 0,12 * * * ~/renew-cert.sh") | crontab -
          fi

          echo "SSL setup completed successfully!"
          EOF
          chmod +x setup-ssl.sh

      - name: Create SSH key
        run: |
          mkdir -p ~/.ssh/
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy.key
          chmod 600 ~/.ssh/deploy.key
          ssh-keyscan -H ${{ secrets.HOST }} >> ~/.ssh/known_hosts

      - name: Check EC2 Connection
        run: |
          ssh -i ~/.ssh/deploy.key ${{ secrets.USERNAME }}@${{ secrets.HOST }} 'echo "Connection successful!"'

      - name: Deploy to EC2
        run: |
          # Stop any running application
          ssh -i ~/.ssh/deploy.key ${{ secrets.USERNAME }}@${{ secrets.HOST }} 'pm2 delete plants-api || true'
          
          # Create app directory if it doesn't exist
          ssh -i ~/.ssh/deploy.key ${{ secrets.USERNAME }}@${{ secrets.HOST }} 'mkdir -p /home/${{ secrets.USERNAME }}/app/ssl'
          
          # Copy files
          rsync -avz --delete -e "ssh -i ~/.ssh/deploy.key" ./* ${{ secrets.USERNAME }}@${{ secrets.HOST }}:/home/${{ secrets.USERNAME }}/app/
          rsync -avz --delete -e "ssh -i ~/.ssh/deploy.key" ./.* ${{ secrets.USERNAME }}@${{ secrets.HOST }}:/home/${{ secrets.USERNAME }}/app/ 2>/dev/null || true
          
          # Make scripts executable
          ssh -i ~/.ssh/deploy.key ${{ secrets.USERNAME }}@${{ secrets.HOST }} 'cd /home/${{ secrets.USERNAME }}/app && chmod +x ./reset.sh ./setup-ssl.sh'
          
          # Run SSL setup script
          echo "Setting up SSL certificates..."
          ssh -i ~/.ssh/deploy.key ${{ secrets.USERNAME }}@${{ secrets.HOST }} 'cd /home/${{ secrets.USERNAME }}/app && ./setup-ssl.sh'
          
          # Make reset.sh executable and run it
          echo "Running reset script..."
          ssh -i ~/.ssh/deploy.key ${{ secrets.USERNAME }}@${{ secrets.HOST }} 'cd /home/${{ secrets.USERNAME }}/app && ./reset.sh'
          
          # Wait for reset script to complete (60 seconds)
          echo "Waiting for reset script to complete..."
          sleep 60
          
          # Start the application with PM2
          echo "Starting application with PM2..."
          ssh -i ~/.ssh/deploy.key ${{ secrets.USERNAME }}@${{ secrets.HOST }} 'cd /home/${{ secrets.USERNAME }}/app && NODE_ENV=production pm2 start npm --name "plants-api" -- start'

      - name: Verify Deployment
        run: |
          echo "Waiting for application to start..."
          sleep 10
          ssh -i ~/.ssh/deploy.key ${{ secrets.USERNAME }}@${{ secrets.HOST }} 'pm2 status'
          
          # Check if the app is responding (HTTP)
          echo "Checking if API is responding (HTTP)..."
          ssh -i ~/.ssh/deploy.key ${{ secrets.USERNAME }}@${{ secrets.HOST }} 'curl -sSf http://localhost:3000/ || echo "Warning: API not responding on localhost"'
          
          # Check if the app is responding (HTTPS)
          echo "Checking if API is responding (HTTPS)..."
          ssh -i ~/.ssh/deploy.key ${{ secrets.USERNAME }}@${{ secrets.HOST }} 'curl -sSf -k https://localhost:3443/ || echo "Warning: API not responding on HTTPS"'

      - name: Get EC2 Public Domain
        id: ec2-domain
        run: |
          EC2_DOMAIN=$(ssh -i ~/.ssh/deploy.key ${{ secrets.USERNAME }}@${{ secrets.HOST }} 'curl -s http://169.254.169.254/latest/meta-data/public-hostname')
          echo "domain=$EC2_DOMAIN" >> $GITHUB_OUTPUT

      - name: Deployment Summary
        run: |
          echo "âœ… Deployment to EC2 completed"
          echo "ğŸŒ HTTP API: http://${{ secrets.HOST }}:3000/"
          echo "ğŸŒ HTTPS API: https://${{ secrets.HOST }}:3443/"
          echo "ğŸŒ API endpoints:"
          echo "   - http://ec2-13-59-190-75.us-east-2.compute.amazonaws.com:3000/api/plantas"
          echo "   - http://ec2-13-59-190-75.us-east-2.compute.amazonaws.com:3000/api/tipos-planta"
          echo "   - http://ec2-13-59-190-75.us-east-2.compute.amazonaws.com:3000/api/plantas/1"
          echo "   - https://ec2-13-59-190-75.us-east-2.compute.amazonaws.com:3443/api/plantas"
          echo "   - https://ec2-13-59-190-75.us-east-2.compute.amazonaws.com:3443/api/tipos-planta"
          echo "   - https://ec2-13-59-190-75.us-east-2.compute.amazonaws.com:3443/api/plantas/1"
          echo "ğŸ” To check logs: ssh -i ~/.ssh/deploy.key ${{ secrets.USERNAME }}@${{ secrets.HOST }} 'pm2 logs plants-api'"